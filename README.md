![Project Image](CV101.png)
# Computer Vision 101 Repository by João Ataíde

This repository is dedicated to his practices from the course "Computer Vision 1: Introduction (Python)".

## Course Link
You can access the course at [Computer Vision 1: Introduction (Python)](https://opencv.org/courses)

## Certificate
João Ataíde has successfully completed the course and received a certificate. You can view the certificate [here](https://courses.opencv.org/certificates/8a56e3b3421945f799361f3f28cf44fe).

## Projects
- [`Instagram_filters-project.ipynb`](https://github.com/jvataidee/ComputerVision101/blob/main/Instagram_filters-project.ipynb):This project aims to replicate how Instagram filters work. Users created two Instagram-like filters: a pencil sketch filter, which generates a sketch of the existing image, and a cartoon filter, which produces a "cartoonized" version of the input image.
- [`blemish-project.py`](https://github.com/jvataidee/ComputerVision101/blob/main/blemish-project.py):This project utilizes the OpenCV library to remove imperfections from an image using the inpaint function. It allows the user to click on blemishes, creating a mask that is used to inpaint the image and remove the imperfections. The program also provides instructions for the user, including resetting the image, adjusting the brush radius, and exiting the program.
- [`cromakey-project.py`](https://github.com/jvataidee/ComputerVision101/blob/main/cromakey-project.py):This project involves applying chroma keying to a video by replacing a specified color patch with a background image. The program reads frames from an input video, applies chroma keying using trackbars for color patch, tolerance, and smoothing, and writes the processed frames to an output video. The resulting frames are displayed in real-time, and the program can be exited by pressing 'q'. The chroma keying process includes converting the frames to HSV, creating a mask based on the color patch and tolerance, applying morphological operations for smoothing, and combining the foreground and background images. Optionally, color projection can be enabled for further adjustment of the result.
- [`assigment_featureimagealignment.ipynb`](https://github.com/jvataidee/ComputerVision101/blob/main/assigment_featureimagealignment.ipynb):This project addresses the restoration of misaligned historical images, feature detection and matching, homography calculation, and warping to achieve an aligned, colorized image. It's an application of computer vision to preserve history and visual memory. Users work with the Prokudin-Gorskii collection, which contains some of the earliest color images in history.
- [`assigment_panorama.ipynb`](https://github.com/jvataidee/ComputerVision101/blob/main/assigment_panorama.ipynb):This project focuses on creating panoramic images using OpenCV. Images are read and stitched together to create a larger panoramic image, which is then saved and returned.
- [`assignment-autofocus.ipynb`](https://github.com/jvataidee/ComputerVision101/blob/main/assigment_panorama.ipynb):This project focuses on implementing measures of focus for determining the sharpest image in a video sequence. Two methods are implemented: the Variance of absolute values of Laplacian and the Sum Modified Laplacian. The implementation involves calculating the sharpness measure for each frame in the video, comparing them, and identifying the frame with the highest measure of focus. The assignment also includes manually specifying the Region of Interest (ROI) for the flower region in the frame. The grading rubric consists of implementing both methods, and an overall submission evaluation.
- [`skin-smoothing_project.ipynb`](https://github.com/jvataidee/ComputerVision101/blob/main/skin-smoothing_project.ipynb):In this project, an image is loaded, and faces are detected using the Haar cascade classifier. Then, a bilateral filter is applied to the detected regions to smooth the image while preserving the edges. The final result is displayed in a figure with multiple subplots, showing the original image, the detected face, the revised face after the filter, and the final image with the processed faces.
- [`sunglasses-filter_project.py`](https://github.com/jvataidee/ComputerVision101/blob/main/sunglasses-filter_project.py): In this script, the OpenCV library is used to detect faces and eyes in a live video stream from the webcam. A pair of sunglasses, represented by a PNG image with an alpha channel, is loaded and overlaid onto the detected faces. The script continuously captures frames from the video stream, converts them to grayscale, and applies the sunglasses filter to the frames using the add_sunglasses function. The resulting frames, with sunglasses superimposed on the faces, are displayed in a window titled "Sunglasses Filter" until the user presses the 'q' key to quit the application.
- [`scaning-documents_project.py`](https://github.com/jvataidee/ComputerVision101/blob/main/scaning-documents_project.py):In this script, the OpenCV library is utilized for document scanning. The preprocess function takes an image, converts it to grayscale, applies Gaussian blur, and performs Canny edge detection. The find_contour function finds the contour with the largest area from the edges. The four_point_transform function applies a perspective transformation to the image based on the four corner points of the detected contour. The document_scanner function reads an image, preprocesses it, detects the contour, approximates it to obtain the four points, draws the contour and numbered vertices on the original image, and displays it. It also applies the perspective transformation and shows the resulting "Scanned Document" image. Pressing the 'q' key saves the corrected image as "scanned-form-corrected.jpg".
- [`traking-detection_project.py`](https://github.com/jvataidee/ComputerVision101/blob/main/traking-detection_project.py):This script showcases object detection and tracking using the SSD model in OpenCV. It loads the model, reads a video file, and performs object detection on each frame. The "sports ball" objects are tracked using the CSRT algorithm, and the resulting frames with bounding boxes are displayed and saved to an output video file. The script provides a comprehensive example of combining object detection and tracking for video analysis tasks.

https://github.com/jvataidee/ComputerVision101/blob/main/output_video.mp4
 
## Repository Content
The repository contains various Jupyter notebooks related to the course.

## Additional Information
- No releases published
- No packages published
